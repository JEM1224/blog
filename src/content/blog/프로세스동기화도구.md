---
title: "프로세스 동기화 도구들"
pubDatetime: 2024-01-27T14:55:21.000Z
full_path: "src/content/blog/프로세스동기화도구.md"
description: "null"
tags: 
  - "cs"
---


### TOC

# 프로세스 동기화 도구들

## 프로세스가 동시에 실행될 때 반드시 동기화를 거친다.
프로세스 동기화란  **프로세스들 사이의 수행시기**를 맞추는 것이다.
프로세스들 사이의 수행 시기를 맞춘다는 의미는 크게 2가지로 나뉜다. 
### 1. 실행 순서 제어를 위한 동기화
writer 프로세스와 reader 프로세스가 동시에 실행 중이라고 가정할 때  두 프로세스는 아무 순서대로 실행 돼서는 안된다. reader 프로세스는 ‘book 안에 값이 존재한다’ 는 특정 조건이 만족 되어야만 실행을 이어나갈 수 있다.

### 2. 상호 배제를 위한 동기화
| 상호 배제 :  공유가 불가능한 자원의 동시 사용을 피하기 위해 사용하는 알고리즘 이다.

프로세스 A ( 계좌 잔액을 읽음 → 읽어 들인 잔액에서 2만원을 더함 → 더한 값을 저장)  
프로세스 B ( 계좌 잔액을 읽음 → 읽어 들인 잔액에서 5만원을 더함 → 더한 값을 저장)   

현재 잔액이 10만원이고 프로세스 A 와 B가 동시에 실행되었다고 가정했을 때 실행 결과 17만원이 계좌에 남을 것이라고 생각하지만 동기화가 이루어지지 않은 경우 엉뚱한 결과가 나올 수 있다.  왜냐하면 A와 B는 잔액이라는 데이터를 동시에 사용하기 때문이다.  
 -> 동시에 접근해서는 안되는 자원을 동시에 접근하지 못하게 해야 한다.

### 그렇다면 동시에 접근해서는 안되는 자원이란 무엇일까?
위 예시에서 프로세스들은 “잔액”이라는 공동의 자원을 두고 작업을 했는데 이러하는 자원을 **공유 자원**이라고 한다. 이러한 공유자원 중에서 두 개 이상의 프로세스를 동시에 실행하면 문제가 발생하는 자원에 접근하는 코드 영역을 **임계 구역**이라고 한다.  
→ 두 개 이상의 프로세스가 임계 구역에 진입하고자하면 둘 중 하나는 대기해야한다.  
→ 동시 다발적으로 임계구역에  코드를 실행할 때 발생되는 문제를 **레이스 컨디션**이라고 한다.  

### 레이스 컨디션의 발생 예

1. 커널 작업을 수행하는 중에 인터럽트가 발생
2. 프로세스가 system call 하여 커널 모드로 진입하여 작업을 수행하는 도중 문맥 교환이 일어날 때
3. 멀티 프로세서 환경에서 공유 메모리 내의 커널 데이터에 접근할 때 

### 레이스 컨디션이 발생하는 근본적인 이유는 뭘까?

고급언어는 실행과정에서 저급 언어로 변환되어 실행되기 때문이다. 예를 들어 `총합을 1 증가시킨다`라는 코드는 고급언어에서 한 줄로 작성할 수 있지만 저급 언어에서는  `총합 변수를 레지스터에 저장 → 레지스터 값 1증가→ 레지스터 값을 총합 변수에 저장`  총 3 줄로 작성된다. 이처럼 여러줄의 저급 언어로 변환된 고급언어를 한 줄 실행하는 과정에서 문맥교환이 일어날 수 있다.

# 동기화를 위한 대표적인 도구들을 살펴보자

## 임계 구역을 잠금으로써 프로세스간의 상호 배제를 이루는 **뮤텍스 락**

| 뮤텍스락은 동시에 접근해서는 안 되는 자원에 동시에 접근하지 않도록 만드는 도구이다. 

1. 자물쇠 역할 : 프로세스들이 공유하는 전역변수 lock
2. 임계 구역을 잠그는 역할 : acquire 함수
3. 임계 구역을 잠금을 해제하는 역할 : release 함수 

```jsx
acquire(){
	while(lock===true) // 만약 임계 구역이 잠겨 있다면
  .... // 임계 구역이 잠겨있는지 반복적으로 확인
  lock =true; // 만약 임계구역이 잠겨있지 않다면 임계 구역 잠금
}
release(){
   lock =false; //임계 구역 작업이 끝났으니 잠금 해제 
}
```

acquire와 release를 임계 구역 전 후로 호출해서 하나의 프로세스만 임계 구역에 진입하게 한다.

```jsx
acquire(); //자물쇠가 잠겨있는지 확인 , 잠겨있지 않다면 잠그고 들어가기
//임계구역
release(); //자물쇠 반환
```
프로세스는 반복적으로 lock을 확인하는데 이러한 대기 방식을 바쁜 대기(busy wait)라고 한다.  
뮤텍스는 상태가 0,1로 이진 세마포어라고 부르기도 한다. 

## 공유 자원이 여러개 있는 임계 구역 문제도 해결할 수 있는 세마포어

:  공유 자원이 여러개 있는 상황에서도 적용이 가능한 동기화 도구 

1. 임계 구역에  진입할 수 있는 프로세스 개수 : 전역 변수 S
2. 임계 구역에 들어가도 좋은지, 기다려야 할 지를 알려주는 wait 함수
3. 임계 구역 앞에서 기다리는 프로세스에게 가도 좋다고 신호를 주는:signal 함수 

```jsx
wait(){
	S--;
	if(S<0){
		//add this process to queue 해당 프로세스 PCB를 대기큐에 삽입
		sleep(); //대기 상태로 접어듬
	}

}
signal(){
	S++;
  if(S<=0) {
		//remove a process p from queue 대기 큐에 있는 프로세스 P 제거
		wakeup(p)	//프로세스 P 를 대기상태에서 준비상태로 만듬
}
}
```

```jsx
wait();
//임계구역
signal();
```

## 세마포어에 비해 사용자가 사용하기 편리한 동기화 도구인 모니터

세마포어의 잘못된 예시를 생각해보자 

1. wait과 signal 순서를 헷갈린 경우
2. wait과 signal을 중복해서 사용한 경우
3. 세마포를 누락한 경우 

 매번 임계 구역 앞 뒤로 wait과 signal 함수를 명시하는 것은 번거롭고 잘못된 코드를 작성할 수 있다. 그래서 최근에 모니터란 동기화 도구가 등장했다.  모니터는 공유자원과 공유자원에 접근하기 위한 인터페이스를 묶어서 관리하고 프로세스는 반드시 인터페이스를 통해서만 공유자원에 접근하도록 해야한다. 즉, 모니터는 공유자원을 다루는 인터페이스에 접근하기 위한 큐를 만들고 , 모니터 안에 항상 하나의 프로세스만 들어오도록하여 상호 배제를 위한 동기화를 제공한다.  이 외에도 모니터는 실행 순서 제어를 위해 조건 변수를 사용한다. 조건 변수는 wait과 signal 연산을 수행할 수 있다.

1. 특정 프로세스가 아직 실행될 조건이 되지 않았을 때에는 wait을 통해 실행을 중단한다.
2. 특정 프로세스가 실핼될 조건이 충족되었을 때에는 signal을 통해 실행을 재개한다. 

## 뮤텍스와 세마포어의 차이
||뮤텍스|세마포어|
|--|--|--|
|동기화 대상|1개|1개 이상|
|자원 소유| 가능|불가능|
|해제 여부|소유하고 있는 스레드만(락을 획득한)이 해제| 소유하고있지 않는 스레드가 해제|
|기타|프로세스의 범위를 가지며, 프로세스가 종료될 때 자동으로 없어진다|시스템 범위에 걸쳐있고, 파일 시스템 상의 파일로 존재|


참고: 혼자공부하는 컴퓨터 구조+운영체제 

